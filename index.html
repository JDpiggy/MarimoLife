<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greedy Goblin Grab</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #333;
            color: #fff;
            overflow: hidden; /* Prevent scrollbars from game area */
        }

        #game-container {
            position: relative;
            width: 700px; /* Game area width */
            height: 500px; /* Game area height */
            border: 3px solid #555;
            background-color: #4a3b2a; /* Cave-like color */
            overflow: hidden; /* Keep elements inside */
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        .player {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 5px;
            transition: transform 0.1s linear; /* For smooth bump effect */
        }

        #player1 {
            background-color: #2ecc71; /* Goblin Greenfoot */
            border: 2px solid #27ae60;
        }

        #player2 {
            background-color: #f1c40f; /* Goblin Goldtooth */
            border: 2px solid #f39c12;
        }

        .treasure {
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background-image: radial-gradient(circle, #fff, gold);
            box-shadow: 0 0 5px gold;
        }
        .ruby { background-image: radial-gradient(circle, #ffcccc, #e74c3c); box-shadow: 0 0 5px #e74c3c;}
        .sapphire { background-image: radial-gradient(circle, #ccffff, #3498db); box-shadow: 0 0 5px #3498db;}
        .diamond { background-image: radial-gradient(circle, #fff, #ecf0f1); box-shadow: 0 0 8px #fff; width: 20px; height: 20px; }


        .hoard {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 2px dashed #777;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #ccc;
        }

        #hoard1 {
            left: 10px;
            top: 10px;
            background-color: rgba(46, 204, 113, 0.2);
        }

        #hoard2 {
            right: 10px;
            top: 10px;
            background-color: rgba(241, 196, 15, 0.2);
        }

        #scoreboard {
            margin-top: 20px;
            font-size: 1.5em;
            display: flex;
            justify-content: space-around;
            width: 700px;
        }

        #player1-score { color: #2ecc71; }
        #player2-score { color: #f1c40f; }

        #timer {
            font-size: 1.5em;
            margin-bottom: 10px;
        }

        #start-button, #reset-button {
            padding: 10px 20px;
            font-size: 1em;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
        }
        #start-button:hover, #reset-button:hover {
            background-color: #2980b9;
        }
        #instructions {
            margin-top: 15px;
            font-size: 0.9em;
            text-align: center;
            max-width: 700px;
            line-height: 1.4;
        }
        .inventory-display {
            font-size: 0.8em;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <h1>Greedy Goblin Grab!</h1>
    <div id="timer">Time Left: 60s</div>
    <div id="scoreboard">
        <div>P1 (Green): <span id="player1-score">0</span> <span id="player1-inventory" class="inventory-display"></span></div>
        <div>P2 (Gold): <span id="player2-score">0</span> <span id="player2-inventory" class="inventory-display"></span></div>
    </div>

    <div id="game-container">
        <div id="player1" class="player"></div>
        <div id="player2" class="player"></div>
        <div id="hoard1" class="hoard">P1 HOARD</div>
        <div id="hoard2" class="hoard">P2 HOARD</div>
        <!-- Treasures will be added here by JavaScript -->
    </div>
    <button id="start-button">Start Game</button>
    <button id="reset-button" style="display:none;">Play Again</button>
    <div id="instructions">
        <strong>Player 1 (Green):</strong> W,A,S,D to Move. SPACE to Grab/Drop. <br>
        <strong>Player 2 (Gold):</strong> Arrow Keys to Move. ENTER to Grab/Drop. <br>
        Grab treasure and bring it back to your hoard! Bump into each other to make them drop loot!
        Max 3 items in inventory.
    </div>

    <script>
        const gameContainer = document.getElementById('game-container');
        const player1Elem = document.getElementById('player1');
        const player2Elem = document.getElementById('player2');
        const hoard1Elem = document.getElementById('hoard1');
        const hoard2Elem = document.getElementById('hoard2');
        const player1ScoreElem = document.getElementById('player1-score');
        const player2ScoreElem = document.getElementById('player2-score');
        const player1InventoryElem = document.getElementById('player1-inventory');
        const player2InventoryElem = document.getElementById('player2-inventory');
        const timerElem = document.getElementById('timer');
        const startButton = document.getElementById('start-button');
        const resetButton = document.getElementById('reset-button');

        const GAME_WIDTH = gameContainer.clientWidth;
        const GAME_HEIGHT = gameContainer.clientHeight;
        const PLAYER_SIZE = 30;
        const TREASURE_SIZE = 15;
        const DIAMOND_SIZE = 20;
        const HOARD_SIZE = 60;
        const PLAYER_SPEED = 8; // Reduced speed for better control
        const MAX_INVENTORY = 3;
        const GAME_DURATION = 60; // seconds

        let player1 = { x: 50, y: GAME_HEIGHT / 2 - PLAYER_SIZE / 2, score: 0, inventory: [] };
        let player2 = { x: GAME_WIDTH - 50 - PLAYER_SIZE, y: GAME_HEIGHT / 2 - PLAYER_SIZE / 2, score: 0, inventory: [] };
        let treasures = [];
        let timeLeft = GAME_DURATION;
        let gameInterval;
        let gameRunning = false;

        const TREASURE_TYPES = [
            { type: 'gold', value: 1, class: 'treasure', size: TREASURE_SIZE },
            { type: 'ruby', value: 5, class: 'treasure ruby', size: TREASURE_SIZE },
            { type: 'sapphire', value: 10, class: 'treasure sapphire', size: TREASURE_SIZE },
            { type: 'diamond', value: 25, class: 'treasure diamond', size: DIAMOND_SIZE }
        ];

        function updatePlayerPosition(player, playerElem) {
            playerElem.style.left = player.x + 'px';
            playerElem.style.top = player.y + 'px';
        }

        function createTreasureElement(treasure) {
            const elem = document.createElement('div');
            elem.className = treasure.class;
            elem.style.left = treasure.x + 'px';
            elem.style.top = treasure.y + 'px';
            if (treasure.type === 'diamond') {
                 elem.style.width = DIAMOND_SIZE + 'px';
                 elem.style.height = DIAMOND_SIZE + 'px';
            }
            treasure.element = elem; // Store reference to DOM element
            gameContainer.appendChild(elem);
            return elem;
        }

        function spawnTreasure() {
            if (treasures.length >= 15 || !gameRunning) return; // Max 15 treasures on screen

            const typeIndex = Math.floor(Math.random() * TREASURE_TYPES.length);
            // Make diamonds rarer
            let randomType = TREASURE_TYPES[typeIndex];
            if (Math.random() > 0.85 && randomType.type !== 'diamond') { // Higher chance for diamond
                randomType = TREASURE_TYPES.find(t => t.type === 'diamond');
            } else if (Math.random() > 0.6 && (randomType.type === 'diamond' || randomType.type === 'sapphire')) {
                 randomType = TREASURE_TYPES[Math.floor(Math.random() * 2)]; // gold or ruby
            }


            const treasure = {
                x: Math.random() * (GAME_WIDTH - randomType.size * 2) + randomType.size,
                y: Math.random() * (GAME_HEIGHT - randomType.size * 2) + randomType.size,
                ...randomType // spread type, value, class, size
            };

            // Avoid spawning on hoards
            if (checkCollision(treasure, {x: hoard1Elem.offsetLeft, y: hoard1Elem.offsetTop, width: HOARD_SIZE, height: HOARD_SIZE}) ||
                checkCollision(treasure, {x: hoard2Elem.offsetLeft, y: hoard2Elem.offsetTop, width: HOARD_SIZE, height: HOARD_SIZE})) {
                spawnTreasure(); // Try again
                return;
            }

            createTreasureElement(treasure);
            treasures.push(treasure);
        }
        
        function spawnSpecificTreasure(x, y, type, value, className, size) {
            const treasure = {
                x: Math.max(0, Math.min(x, GAME_WIDTH - size)), // Keep within bounds
                y: Math.max(0, Math.min(y, GAME_HEIGHT - size)),
                type: type,
                value: value,
                class: className,
                size: size
            };
            createTreasureElement(treasure);
            treasures.push(treasure);
        }


        function checkCollision(rect1, rect2) {
            // Check if rect1 has width/height, if not, use its size property
            const r1Width = rect1.width !== undefined ? rect1.width : rect1.size;
            const r1Height = rect1.height !== undefined ? rect1.height : rect1.size;
            const r2Width = rect2.width !== undefined ? rect2.width : rect2.size;
            const r2Height = rect2.height !== undefined ? rect2.height : rect2.size;

            return rect1.x < rect2.x + r2Width &&
                   rect1.x + r1Width > rect2.x &&
                   rect1.y < rect2.y + r2Height &&
                   rect1.y + r1Height > rect2.y;
        }

        function updateScores() {
            player1ScoreElem.textContent = player1.score;
            player2ScoreElem.textContent = player2.score;
            player1InventoryElem.textContent = `(${player1.inventory.length}/${MAX_INVENTORY}) ${player1.inventory.map(t=>t.type[0]).join(',')}`;
            player2InventoryElem.textContent = `(${player2.inventory.length}/${MAX_INVENTORY}) ${player2.inventory.map(t=>t.type[0]).join(',')}`;

        }

        function handlePlayerAction(player, playerElem, hoardElem) {
            // Check for treasure collection
            for (let i = treasures.length - 1; i >= 0; i--) {
                const treasure = treasures[i];
                if (checkCollision(player, treasure)) {
                    if (player.inventory.length < MAX_INVENTORY) {
                        player.inventory.push(treasure);
                        gameContainer.removeChild(treasure.element);
                        treasures.splice(i, 1);
                        // console.log((player === player1 ? "P1" : "P2") + " picked up " + treasure.type);
                        break; // Pick up one at a time
                    }
                }
            }

            // Check for depositing treasure
            const hoardRect = {
                x: hoardElem.offsetLeft,
                y: hoardElem.offsetTop,
                width: HOARD_SIZE,
                height: HOARD_SIZE
            };
            if (checkCollision(player, hoardRect)) {
                if (player.inventory.length > 0) {
                    player.inventory.forEach(item => player.score += item.value);
                    // console.log((player === player1 ? "P1" : "P2") + " deposited " + player.inventory.length + " items. New score: " + player.score);
                    player.inventory = [];
                }
            }
            updateScores();
        }
        
        function handlePlayerCollision() {
            if (checkCollision({...player1, width: PLAYER_SIZE, height: PLAYER_SIZE}, {...player2, width: PLAYER_SIZE, height: PLAYER_SIZE})) {
                // Simple bump: one random item from one player drops
                // A more complex system could check who initiated the bump
                const p1BumpsP2 = player1.lastMoveTime > player2.lastMoveTime; // A naive way to check who moved last
                const p2BumpsP1 = player2.lastMoveTime > player1.lastMoveTime;

                let bumpedPlayer = null;
                let bumper = null;

                // Basic: if they are overlapping, decide who drops
                if (Math.random() < 0.5 && player1.inventory.length > 0) {
                    bumpedPlayer = player1;
                    bumper = player2;
                } else if (player2.inventory.length > 0) {
                    bumpedPlayer = player2;
                    bumper = player1;
                }


                if (bumpedPlayer && bumpedPlayer.inventory.length > 0) {
                    const droppedItemIndex = Math.floor(Math.random() * bumpedPlayer.inventory.length);
                    const droppedItem = bumpedPlayer.inventory.splice(droppedItemIndex, 1)[0];
                    
                    // Spawn dropped item near the collision
                    const dropX = (player1.x + player2.x) / 2;
                    const dropY = (player1.y + player2.y) / 2;
                    spawnSpecificTreasure(dropX, dropY, droppedItem.type, droppedItem.value, droppedItem.class, droppedItem.size);
                    
                    // console.log((bumpedPlayer === player1 ? "P1" : "P2") + " dropped a " + droppedItem.type);
                    updateScores();

                    // Visual bump effect (optional)
                    const bumpedElem = (bumpedPlayer === player1) ? player1Elem : player2Elem;
                    bumpedElem.style.transform = 'scale(1.2)';
                    setTimeout(() => {
                        bumpedElem.style.transform = 'scale(1)';
                    }, 100);
                }
                 // Prevent players from getting stuck inside each other by pushing them apart slightly
                const overlapX = (PLAYER_SIZE) - Math.abs(player1.x - player2.x);
                const overlapY = (PLAYER_SIZE) - Math.abs(player1.y - player2.y);

                if (overlapX > 0 && overlapY > 0) {
                    const push = 2; // How much to push them apart
                    if (player1.x < player2.x) {
                        player1.x -= Math.min(push, overlapX / 2);
                        player2.x += Math.min(push, overlapX / 2);
                    } else {
                        player1.x += Math.min(push, overlapX / 2);
                        player2.x -= Math.min(push, overlapX / 2);
                    }
                    if (player1.y < player2.y) {
                        player1.y -= Math.min(push, overlapY / 2);
                        player2.y += Math.min(push, overlapY / 2);
                    } else {
                        player1.y += Math.min(push, overlapY / 2);
                        player2.y -= Math.min(push, overlapY / 2);
                    }
                    // Ensure they don't go out of bounds after pushing
                    player1.x = Math.max(0, Math.min(player1.x, GAME_WIDTH - PLAYER_SIZE));
                    player1.y = Math.max(0, Math.min(player1.y, GAME_HEIGHT - PLAYER_SIZE));
                    player2.x = Math.max(0, Math.min(player2.x, GAME_WIDTH - PLAYER_SIZE));
                    player2.y = Math.max(0, Math.min(player2.y, GAME_HEIGHT - PLAYER_SIZE));

                    updatePlayerPosition(player1, player1Elem);
                    updatePlayerPosition(player2, player2Elem);
                }
            }
        }


        const keysPressed = {};
        document.addEventListener('keydown', (e) => {
            if (!gameRunning && (e.key === " " || e.key === "Enter")) {
                 // Allow starting game with action keys if not running and start button visible
                if (startButton.style.display !== 'none') {
                    startGame();
                } else if (resetButton.style.display !== 'none') {
                    resetGame();
                }
                return;
            }
            if (!gameRunning) return;
            keysPressed[e.key.toLowerCase()] = true;

            // Player 1 Action
            if (e.key === ' ') { // Spacebar
                e.preventDefault();
                handlePlayerAction(player1, player1Elem, hoard1Elem);
            }
            // Player 2 Action
            if (e.key === 'Enter') {
                e.preventDefault();
                handlePlayerAction(player2, player2Elem, hoard2Elem);
            }
        });

        document.addEventListener('keyup', (e) => {
            keysPressed[e.key.toLowerCase()] = false;
        });

        function movePlayers() {
            if (!gameRunning) return;

            // Player 1 (WASD)
            if (keysPressed['w']) player1.y -= PLAYER_SPEED;
            if (keysPressed['s']) player1.y += PLAYER_SPEED;
            if (keysPressed['a']) player1.x -= PLAYER_SPEED;
            if (keysPressed['d']) player1.x += PLAYER_SPEED;

            // Player 2 (Arrow Keys)
            if (keysPressed['arrowup']) player2.y -= PLAYER_SPEED;
            if (keysPressed['arrowdown']) player2.y += PLAYER_SPEED;
            if (keysPressed['arrowleft']) player2.x -= PLAYER_SPEED;
            if (keysPressed['arrowright']) player2.x += PLAYER_SPEED;

            // Boundary checks
            player1.x = Math.max(0, Math.min(player1.x, GAME_WIDTH - PLAYER_SIZE));
            player1.y = Math.max(0, Math.min(player1.y, GAME_HEIGHT - PLAYER_SIZE));
            player2.x = Math.max(0, Math.min(player2.x, GAME_WIDTH - PLAYER_SIZE));
            player2.y = Math.max(0, Math.min(player2.y, GAME_HEIGHT - PLAYER_SIZE));
            
            player1.lastMoveTime = Date.now(); // For bump logic
            player2.lastMoveTime = Date.now();


            updatePlayerPosition(player1, player1Elem);
            updatePlayerPosition(player2, player2Elem);
            
            handlePlayerCollision(); // Check for collisions after movement
        }


        function gameLoop() {
            if (!gameRunning) return;

            movePlayers();
            
            if (Math.random() < 0.05) { // Chance to spawn treasure
                spawnTreasure();
            }

            requestAnimationFrame(gameLoop);
        }

        function countdown() {
            if (timeLeft <= 0) {
                clearInterval(gameInterval);
                gameRunning = false;
                timerElem.textContent = "Time's Up!";
                let winnerMessage = "It's a tie!";
                if (player1.score > player2.score) {
                    winnerMessage = "Player 1 (Green) Wins!";
                } else if (player2.score > player1.score) {
                    winnerMessage = "Player 2 (Gold) Wins!";
                }
                alert(winnerMessage + `\nP1: ${player1.score} - P2: ${player2.score}`);
                resetButton.style.display = 'inline-block';
                startButton.style.display = 'none';
                return;
            }
            timeLeft--;
            timerElem.textContent = `Time Left: ${timeLeft}s`;
        }

        function clearTreasures() {
            treasures.forEach(t => {
                if (t.element && t.element.parentNode) {
                    gameContainer.removeChild(t.element);
                }
            });
            treasures = [];
        }

        function resetGame() {
            clearInterval(gameInterval);
            gameRunning = false;
            
            player1 = { x: 50, y: GAME_HEIGHT / 2 - PLAYER_SIZE / 2, score: 0, inventory: [] };
            player2 = { x: GAME_WIDTH - 50 - PLAYER_SIZE, y: GAME_HEIGHT / 2 - PLAYER_SIZE / 2, score: 0, inventory: [] };
            
            clearTreasures();
            
            updatePlayerPosition(player1, player1Elem);
            updatePlayerPosition(player2, player2Elem);
            updateScores();
            
            timeLeft = GAME_DURATION;
            timerElem.textContent = `Time Left: ${timeLeft}s`;
            
            resetButton.style.display = 'none';
            startButton.style.display = 'inline-block';
        }

        function startGame() {
            if (gameRunning) return;
            resetGame(); // Ensure fresh start
            gameRunning = true;
            startButton.style.display = 'none';
            resetButton.style.display = 'none';


            for(let i=0; i<10; i++) spawnTreasure(); // Initial treasures

            gameInterval = setInterval(countdown, 1000);
            requestAnimationFrame(gameLoop); // Start the main game loop
        }

        startButton.addEventListener('click', startGame);
        resetButton.addEventListener('click', resetGame);

        // Initial setup
        updatePlayerPosition(player1, player1Elem);
        updatePlayerPosition(player2, player2Elem);
        updateScores();
         timerElem.textContent = `Time Left: ${GAME_DURATION}s`;
    </script>
</body>
</html>
